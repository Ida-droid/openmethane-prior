import numpy as np
import pytest
import xarray as xr

from openmethane_prior.grid.grid import Grid


def test_grid_attributes():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.dimensions == (8, 10)
    assert test_grid.shape == (10, 8)
    assert test_grid.center_lonlat == (45, 45)
    assert test_grid.origin_xy == (-4, -5)
    assert test_grid.cell_size == (1, 2)

def test_grid_center():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    grid_center_x, grid_center_y = test_grid.projection(45, 45)

    assert test_grid.center_xy == (grid_center_x, grid_center_y)


def test_grid_llc_xy():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    assert test_grid.llc_xy == (41.0, 40.0)

def test_grid_llc_center_xy():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.llc_center_xy == (41.5, 41.0)

def test_grid_cell_area():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.cell_area == 2.0

def test_grid_coords():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    cell_coords_x = test_grid.cell_coords_x()
    cell_coords_y = test_grid.cell_coords_y()

    assert len(cell_coords_x) == 8
    assert cell_coords_x[0] == test_grid.llc_center_xy[0]

    assert len(cell_coords_y) == 10
    assert cell_coords_y[0] == test_grid.llc_center_xy[1]

def test_grid_bounds():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    cell_bounds_x = test_grid.cell_bounds_x()
    cell_bounds_y = test_grid.cell_bounds_y()

    assert len(cell_bounds_x) == 9
    assert cell_bounds_x[0] == test_grid.llc_xy[0]

    assert len(cell_bounds_y) == 11
    assert cell_bounds_y[0] == test_grid.llc_xy[1]

def test_grid_xy_to_lonlat():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.xy_to_lonlat(*test_grid.center_xy) == (45, 45)

def test_grid_projection_coordinates():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    # projection center coords for all cells in the domain
    x_center_coords = test_grid.cell_coords_x()
    y_center_coords = test_grid.cell_coords_y()

    # choose a range of 10x10 coordinates within the domain to spot test, including upper and lower bounds
    x_test_coords = [0, *np.random.randint(test_grid.dimensions[0], size=8), test_grid.dimensions[0] - 1]
    y_test_coords = [0, *np.random.randint(test_grid.dimensions[1], size=8), test_grid.dimensions[1] - 1]

    # note: the coordinates generated by Grid using the pyproj projection have
    # been observed to drift by up to **5 meters** from the coordinates
    # generated by MCIP, due to the differences between MCIPs projection
    # algorithm and ours.
    drift_tolerance = 5 # meters

    for y in y_test_coords:
        for x in x_test_coords:
            # compare the coordinates generated by our Grid class with the
            # LON/LAT coords stored in the input domain file which was
            # generated by MCIP using the same grid parameters.
            expected_coords = (float(x_center_coords[x]), float(y_center_coords[y]))
            projected_coords = test_grid.lonlat_to_xy(*expected_coords)

            # check that our generated coordinates match the coords generated by MCIP
            np.testing.assert_allclose(projected_coords, expected_coords, atol=drift_tolerance)

def test_grid_valid_cell_coords():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.valid_cell_coords((0, 0))
    assert test_grid.valid_cell_coords((1, 1))
    assert test_grid.valid_cell_coords((7, 0))
    assert test_grid.valid_cell_coords((0, 9))
    assert test_grid.valid_cell_coords((7, 9))

    assert not test_grid.valid_cell_coords((-1, 0))
    assert not test_grid.valid_cell_coords((0, -1))
    assert not test_grid.valid_cell_coords((0, 10))
    assert not test_grid.valid_cell_coords((8, 0))
    assert not test_grid.valid_cell_coords((8, 10))

def test_grid_find_cell():
    test_grid = Grid(
        dimensions=(8, 10),
        center_lonlat=(45, 45),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    # one of xy or lonlat must be provided
    with pytest.raises(ValueError, match="xy or lonlat must be provided"):
        test_grid.find_cell()
    with pytest.raises(ValueError, match="provide only one of xy or lonlat"):
        test_grid.find_cell(xy=(0, 0), lonlat=(0, 0))

    # coords should be a tuple of ints
    found = test_grid.find_cell(xy=(41, 40))
    assert found == (0, 0)
    assert type(found) == tuple

    found_x, found_y = found
    assert type(found_x) == int
    assert type(found_y) == int

    # coords inside the grid should succeed
    assert test_grid.find_cell(xy=(41, 40)) == (0, 0)
    assert test_grid.find_cell(xy=(45, 45)) == (4, 2)
    assert test_grid.find_cell(xy=(48.9, 59.9)) == (7, 9)

    assert test_grid.find_cell(xy=test_grid.llc_xy) == (0, 0)

    # coords outside the grid should find None
    assert test_grid.find_cell(xy=(40.9, 39.9)) == None
    assert test_grid.find_cell(xy=(40.9, 40.0)) == None
    assert test_grid.find_cell(xy=(41.0, 39.9)) == None
    assert test_grid.find_cell(xy=(48.9, 60)) == None
    assert test_grid.find_cell(xy=(49.0, 59.9)) == None
    assert test_grid.find_cell(xy=(49.0, 59.9)) == None

def test_grid_lonlat_to_cell_index():
    # set up a grid with a different projection so we can test lon/lat -> x/y conversion
    # using EPSG:7844, which is GDA2020:
    # center: 133.38 -34.51
    # extent: 93.31, -60.55 x 173.34, -8.47
    test_grid = Grid(
        dimensions=(80, 40),
        center_lonlat=(133.38, -34.51),
        origin_xy=(-40, -20),
        cell_size=(1, 1), # EPSG:7844 (GDA2020) uses degrees
        proj_params="EPSG:7844",
    )

    # multiple values as np.array
    np_result = test_grid.lonlat_to_cell_index(
        lon=np.array([100, 130, 160]),
        lat=np.array([-40, -45, -50]),
    )

    np.testing.assert_allclose(np_result, (
        [6, 36, 66],
        [14, 9, 4],
        [True, True, True],
    ))

    # multiple values as xr.DataArray
    xr_result = test_grid.lonlat_to_cell_index(
        lon=xr.DataArray([100.5, 130.5, 160.5]),
        lat=xr.DataArray([-40.5, -45.5, -50.5]),
    )

    np.testing.assert_allclose(xr_result, (
        [7, 37, 67],
        [14, 9, 4],
        [True, True, True],
    ))

    # some points outside the grid
    in_out = test_grid.lonlat_to_cell_index(
        lon=np.array([80, 130, 177, 100, 100, 100]),
        lat=np.array([-40, -45, -50, -55, -40, -13]),
    )
    np.testing.assert_allclose(in_out, (
        [-14, 36, 83, 6, 6, 6], # valid x coords: 0 - 79
        [14, 9, 4, -1, 14, 41], # valid y coords: 0 - 40
        [False, True, False, False, True, False],
    ))
